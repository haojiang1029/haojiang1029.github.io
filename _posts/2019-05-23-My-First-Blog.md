---
layout: post
title: My First Blog!
---

终于也有一个自己的个人博客了，其实有这个想法已经很久了。一直以来自己也想把想法（生活或学习上的）记录下来，但由于种种原因（主要是懒...）没能如愿。之前也写了一些日记，也不过是发发牢骚，自我鼓励。学习和工作上面虽然也有几次想要总结记录的冲动，但往往找不到合适的工具或者有其他事耽搁就不了了之了。仔细想来写博客有几个好处：一是对自己的过去有一个交代，二是锻炼自己的写作能力，三是通过总结能够更清楚自己所犯的错误和逻辑漏洞，当然也方便未来想查看时方便。这是自己的第一篇博客，也希望自己能够坚持写下去。很多时候感觉自己进步很慢，觉得自己当时明白了，但过了一阵子就又忘了。希望写博客能够弥补这一缺陷。因为自己也要读博，接下来会有四五年比较稳定的科研时间，也希望通过写博客增长经验和能力。

第一篇博客还是献给我的硕士毕业论文吧。想来从17年8月来加拿大也快两年了，中间虽然也上了几门课，也实习了，但最有价值的恐怕还是毕业论文。导师对论文很满意，我自己也觉得不错。确实花了不少时间，也取得了一些结果。现在论文已经做完了，就等下月初答辩，自己也想好好总结一下究竟学到了什么。我在想如果向一个学计算机的不同方向的人该怎么介绍自己做的东西，因为其中涉及到的概念和定义实在很多，也有不少比较抽象的理解，能把别人讲明白确实不容易。就让我试一下吧。

首先我的题目是：一种针对物联网的编程模型。当刚开始拿到这个题目时，我也比较😳。谷歌解释编程模型是指对于底层计算机系统的一种抽象，在其中可以表示算法和数据结构。还是有点抽象，我的理解是编程模型定义了一种高阶的编程范式，比如 _MapReduce_ ，虽然它没有给出具体的算法和数据结构，但它给出了一般的步骤。这样说来我的论文主要分为三大块：一是对物联网资源的抽象，也就是数据结构，二是给出了应用程序的一般运行步骤，即Event-Condition-Action，三是原型系统的实现。下面对这三点逐一介绍吧。

1. 资源是任意可以用URI表示的实体，可以是物理实体比如传感器，也可以是对应的digital twin。导师再三强调我们要在high-level上表示资源。这里插上两句我认为导师给我两点比较重要的启发：一是把问题**抽象化**，二是要考虑**可扩展性**。这两点几乎每次组会和讨论都或多或少地涉及，由此说明了它们对于我们这个方向的重要性。所谓的抽象资源，是指对于给出的问题域，比如天气，给出对天气资源的一般描述。这里的描述定义了资源提供的接口，输入和输出等。这样在实际应用时，我们就用这样一个抽象资源（模板）来描述我们想从问题域得到的数据，比如温度，湿度，气压等。当然在具体应用时，我们还是要对具体的资源，比如WeatherNetwork进行操作。这样就涉及到了一个关键的步骤叫作实例化，也就是从抽象资源到具体资源的过程。我论文所做的主要工作也就在此。通过导师的讲解和参考其他人的工作，这里我的实例化过程主要分成两个部分：语义互操作和资源选取算法。所谓语义互操作是指对于同一概念的不同表述进行统一处理，最典型的例子恐怕就是中英文对照吧，温度和temperature是指同一个意思。这样即使资源模板和具体资源中的字段名称不同，我们也可以通过映射和替换拿到需要的数据。当然语义互操作还涉及很多高深的内容，我的论文就没有继续研究了。第二个重要的部分就是算法，这也算是论文的一个highlight。对于在实例化过程中选择哪一个具体的资源，在实际中我们要考虑很多因素，比如价格，响应时间，可信度等等。有了这些评价指标，我们就可以给每个资源计算一个价值。实际应用时往往会涉及到多个问题领域，也就是在每个资源组中选取最合适的一个，然后组合它们。我们还定义了一个限制条件，比如价格不能超过一定的数目。这样我们的资源选择问题就被转换成了多选择背包问题。至于算法的具体实现也在论文里，这里也就不再赘述。发现的一个问题是自己对于算法到程序的转化还是理解得不够，有时候虽然知道了算法步骤，但实际编程实现时还是会遇到障碍，也许还是缺少练习吧。所以在读博期间还是不能忽视算法的训练。

2. ECA范式是物联网领域流行的编程模型，它的一般步骤是：当一个事件发生时，先判断条件是否成立，如果条件满足，则执行相应的动作。这里的关键是建立条件和动作对应的模型。因为它们的模型可以很复杂，这里我们应用了Goal Modeling来对条件和动作进行建模以表达结点之间复杂的关系。比如在条件模型中，一个条件的满足导致另一个条件的否认。在动作模型中，不同的动作可以有不同的时序关系等。Goal Modeling还有一个好处是它支持推理，即对于条件模型，给出叶子结点的满足度，可以计算出根结点的满足度。对于动作模型，如果要执行根结点，通过推理可以计算出叶子结点的执行次序。这两个推理过程分别选自于导师之前两个学生的博士毕业论文和硕士毕业论文，所以也是很重要的两个研究方向。但对于我的毕业论文而言，只需要理解它们的过程，会调用它们就行了。

3. 我的毕业论文的第三个部分是系统实现，也就是运用前面提到的编程抽象和编程范式实现一个原型系统来验证它们的可行性。这里引入一个关键的概念叫作中间件，也可能是我读博研究的方向之一。中间件是介于硬件和应用之间的软件系统，主要用来方便地传输数据。它定义了地址空间结构来存储数据，实现了基本的读写数据的方法，也可能实现了一些比较高级的功能比如安全性和读取历史数据等等。因为我们的编程模型是基于事件的，所以选取的中间件也是基于事件的，也就是系统中的各部分通过事件来传输数据。基于事件的中间件可以选用发布/订阅模型，即生产者发布事件，消费者注册并收到感兴趣的事件。这种类型的中间件最大的优点就是可扩展性。因为生产者和消费者不是一对一而是多对多的关系，它们不需要知道彼此的地址来进行通信，而是通过一个中间的媒介（Channel）来传递事件。这样也就实现了软件工程领域的一个基本原则：loose coupling. 说回到论文，我们用的是OPC UA中间件，原本是为工业互联网开发的中间件平台。通过中间件可以将我的论文的各个组件串联起来，对于各个组件可以设计不同的中间件客户端以实现不同的功能。比如资源中间件可以做实例化和获取数据，条件和动作中间件可以构建模型和推理。它们之间的通信就可以通过中间件来进行，比如资源中间件的输出可以对应到条件和动作中间件的输入，动作中间件的输出又可以反馈到资源中间件的输入。当系统运行时，各个已经注册感兴趣事件的客户端就被触发从而执行各自的功能。这个部分也涉及到了比较多的编程，但由于都是基于对中间件的理解和方法论的，所以实现起来并不是很难，唯一需要注意的一点是细心。

以上就是我对自己的硕士毕业论文的大致介绍和总结，希望讲得足够清楚和(oﾟvﾟ)ノ明白。回顾起来，真正花在论文上的时间也就一年左右，这之中当然还有很多熟悉项目和浪费掉的时间，下次希望能充分利用已有的时间多做事情，要真正地get the things done而不是pseudo working. 

